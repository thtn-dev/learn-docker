# Dockerfile 101: H∆∞·ªõng d·∫´n t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao

## M·ª•c l·ª•c
1. [Gi·ªõi thi·ªáu v√† kh√°i ni·ªám c∆° b·∫£n](#gi·ªõi-thi·ªáu-v√†-kh√°i-ni·ªám-c∆°-b·∫£n)
2. [C·∫•u tr√∫c v√† syntax c·ªßa Dockerfile](#c·∫•u-tr√∫c-v√†-syntax-c·ªßa-dockerfile)
3. [C√°c instruction c∆° b·∫£n](#c√°c-instruction-c∆°-b·∫£n)
4. [Layers v√† Docker Cache](#layers-v√†-docker-cache)
5. [Best Practices c∆° b·∫£n](#best-practices-c∆°-b·∫£n)
6. [C√°c instruction n√¢ng cao](#c√°c-instruction-n√¢ng-cao)
7. [Multi-stage builds](#multi-stage-builds)
8. [Security trong Dockerfile](#security-trong-dockerfile)
9. [Optimization v√† Performance](#optimization-v√†-performance)
10. [Troubleshooting v√† Debug](#troubleshooting-v√†-debug)
11. [Examples th·ª±c t·∫ø](#examples-th·ª±c-t·∫ø)

---

## Gi·ªõi thi·ªáu v√† kh√°i ni·ªám c∆° b·∫£n

### Dockerfile l√† g√¨?

Dockerfile l√† m·ªôt file text ƒë∆°n gi·∫£n ch·ª©a m·ªôt chu·ªói c√°c instruction (l·ªánh) m√† Docker engine s·∫Ω ƒë·ªçc v√† th·ª±c thi ƒë·ªÉ t·∫°o ra m·ªôt Docker image. B·∫°n c√≥ th·ªÉ hi·ªÉu Dockerfile nh∆∞ m·ªôt "c√¥ng th·ª©c n·∫•u ƒÉn" - n√≥ m√¥ t·∫£ t·ª´ng b∆∞·ªõc c·∫ßn thi·∫øt ƒë·ªÉ t·∫°o ra m·ªôt m√¥i tr∆∞·ªùng ·ª©ng d·ª•ng ho√†n ch·ªânh.

H√£y t∆∞·ªüng t∆∞·ª£ng b·∫°n mu·ªën chu·∫©n b·ªã m·ªôt cƒÉn ph√≤ng cho kh√°ch. Dockerfile s·∫Ω m√¥ t·∫£ t·ª´ng b∆∞·ªõc: ch·ªçn lo·∫°i ph√≤ng (base image), s·∫Øp x·∫øp ƒë·ªì ƒë·∫°c (copy files), c√†i ƒë·∫∑t ti·ªán nghi (install packages), v√† cu·ªëi c√πng l√† c√°ch kh√°ch s·∫Ω s·ª≠ d·ª•ng ph√≤ng (run application).

### T·∫°i sao c·∫ßn Dockerfile?

Dockerfile gi·∫£i quy·∫øt b√†i to√°n "It works on my machine" b·∫±ng c√°ch:
- **T√°i t·∫°o m√¥i tr∆∞·ªùng nh·∫•t qu√°n**: M·ªçi ng∆∞·ªùi ƒë·ªÅu c√≥ c√πng m·ªôt m√¥i tr∆∞·ªùng runtime
- **T·ª± ƒë·ªông h√≥a vi·ªác setup**: Kh√¥ng c·∫ßn c√†i ƒë·∫∑t th·ªß c√¥ng nhi·ªÅu l·∫ßn
- **Version control**: Dockerfile c√≥ th·ªÉ ƒë∆∞·ª£c qu·∫£n l√Ω b·∫±ng Git nh∆∞ code
- **Scalability**: D·ªÖ d√†ng deploy tr√™n nhi·ªÅu server kh√°c nhau

### Quy tr√¨nh ho·∫°t ƒë·ªông

```
Dockerfile ‚Üí docker build ‚Üí Docker Image ‚Üí docker run ‚Üí Container
```

Dockerfile ƒë∆∞·ª£c build th√†nh image, image ƒë∆∞·ª£c run th√†nh container. Container l√† n∆°i ·ª©ng d·ª•ng c·ªßa b·∫°n th·ª±c s·ª± ch·∫°y.

---

## C·∫•u tr√∫c v√† syntax c·ªßa Dockerfile

### Quy t·∫Øc c∆° b·∫£n

Dockerfile tu√¢n theo c√°c quy t·∫Øc syntax ƒë∆°n gi·∫£n:
- M·ªói instruction n·∫±m tr√™n m·ªôt d√≤ng ri√™ng bi·ªát
- Instruction kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng, nh∆∞ng convention l√† vi·∫øt HOA
- D√≤ng ƒë·∫ßu ti√™n ph·∫£i l√† FROM (tr·ª´ khi c√≥ ARG tr∆∞·ªõc FROM)
- Comments b·∫Øt ƒë·∫ßu b·∫±ng k√Ω t·ª± `#`

### C·∫•u tr√∫c c∆° b·∫£n

```dockerfile
# Comment: ƒê√¢y l√† comment
FROM base_image:tag

# Metadata
LABEL maintainer="your-email@example.com"

# Environment setup
ENV NODE_ENV=production

# Working directory
WORKDIR /app

# Copy files
COPY . .

# Install dependencies
RUN npm install

# Expose port
EXPOSE 3000

# Define how to run the application
CMD ["npm", "start"]
```

### Docker Context

Khi b·∫°n ch·∫°y `docker build .`, d·∫•u ch·∫•m `.` ƒë·∫°i di·ªán cho build context. Docker s·∫Ω g·ª≠i to√†n b·ªô th∆∞ m·ª•c hi·ªán t·∫°i ƒë·∫øn Docker daemon. ƒêi·ªÅu n√†y c√≥ nghƒ©a:
- M·ªçi file trong th∆∞ m·ª•c c√≥ th·ªÉ ƒë∆∞·ª£c COPY v√†o image
- Th∆∞ m·ª•c c√†ng l·ªõn, build c√†ng ch·∫≠m
- S·ª≠ d·ª•ng `.dockerignore` ƒë·ªÉ lo·∫°i tr·ª´ file kh√¥ng c·∫ßn thi·∫øt

---

## C√°c instruction c∆° b·∫£n

### FROM - Ch·ªçn base image

FROM l√† instruction b·∫Øt bu·ªôc ƒë·∫ßu ti√™n, ƒë·ªãnh nghƒ©a image g·ªëc m√† container c·ªßa b·∫°n s·∫Ω ƒë∆∞·ª£c x√¢y d·ª±ng d·ª±a tr√™n ƒë√≥.

```dockerfile
# S·ª≠ d·ª•ng image ch√≠nh th·ª©c c·ªßa Node.js
FROM node:18

# S·ª≠ d·ª•ng image v·ªõi tag c·ª• th·ªÉ ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n
FROM node:18.17.0-alpine

# S·ª≠ d·ª•ng image t·ª´ registry kh√°c
FROM registry.company.com/base-image:latest
```

**L∆∞u √Ω quan tr·ªçng**: Lu√¥n s·ª≠ d·ª•ng tag c·ª• th·ªÉ thay v√¨ `latest` trong production ƒë·ªÉ tr√°nh breaking changes kh√¥ng mong mu·ªën.

### WORKDIR - Thi·∫øt l·∫≠p th∆∞ m·ª•c l√†m vi·ªác

WORKDIR thi·∫øt l·∫≠p th∆∞ m·ª•c l√†m vi·ªác cho c√°c instruction ti·∫øp theo. N√≥ t∆∞∆°ng t·ª± nh∆∞ l·ªánh `cd` trong terminal.

```dockerfile
# T·∫°o v√† chuy·ªÉn ƒë·∫øn th∆∞ m·ª•c /app
WORKDIR /app

# C√°c instruction ti·∫øp theo s·∫Ω ƒë∆∞·ª£c th·ª±c thi trong /app
COPY package.json .
RUN npm install
```

**T·∫°i sao c·∫ßn WORKDIR?**
- Tr√°nh l√†m vi·ªác trong th∆∞ m·ª•c root (/) g√¢y b·ª´a b·ªôn
- T·∫°o structure r√µ r√†ng cho ·ª©ng d·ª•ng
- C√°c relative paths s·∫Ω ƒë∆∞·ª£c t√≠nh t·ª´ WORKDIR

### COPY vs ADD - Sao ch√©p files

C·∫£ hai instruction ƒë·ªÅu copy files t·ª´ host v√†o container, nh∆∞ng c√≥ s·ª± kh√°c bi·ªát:

```dockerfile
# COPY: ƒê∆°n gi·∫£n, ch·ªâ copy files/folders
COPY package.json /app/
COPY src/ /app/src/
COPY . .  # Copy t·∫•t c·∫£ t·ª´ build context

# ADD: C√≥ th√™m t√≠nh nƒÉng ƒë·∫∑c bi·ªát
ADD archive.tar.gz /app/  # T·ª± ƒë·ªông extract
ADD https://example.com/file.txt /app/  # Download t·ª´ URL
```

**Best practice**: S·ª≠ d·ª•ng COPY tr·ª´ khi b·∫°n th·ª±c s·ª± c·∫ßn t√≠nh nƒÉng ƒë·∫∑c bi·ªát c·ªßa ADD.

### RUN - Th·ª±c thi commands

RUN th·ª±c thi commands trong container v√† t·∫°o ra layer m·ªõi.

```dockerfile
# Shell form: Ch·∫°y trong shell (/bin/sh -c)
RUN apt-get update && apt-get install -y \
    curl \
    vim \
    git

# Exec form: Ch·∫°y tr·ª±c ti·∫øp binary
RUN ["apt-get", "update"]
RUN ["apt-get", "install", "-y", "curl"]
```

**K·ªπ thu·∫≠t t·ªëi ∆∞u h√≥a**: K·∫øt h·ª£p nhi·ªÅu commands trong m·ªôt RUN ƒë·ªÉ gi·∫£m s·ªë layers:

```dockerfile
# Kh√¥ng t·ªët: T·∫°o 3 layers
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get clean

# T·ªët: Ch·ªâ t·∫°o 1 layer
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

### ENV - Environment variables

ENV thi·∫øt l·∫≠p bi·∫øn m√¥i tr∆∞·ªùng s·∫Ω t·ªìn t·∫°i trong container khi ch·∫°y.

```dockerfile
# Syntax c∆° b·∫£n
ENV NODE_ENV=production
ENV PORT=3000

# C√≥ th·ªÉ thi·∫øt l·∫≠p nhi·ªÅu bi·∫øn c√πng l√∫c
ENV NODE_ENV=production \
    PORT=3000 \
    DEBUG=false

# S·ª≠ d·ª•ng bi·∫øn trong c√°c instruction kh√°c
ENV APP_HOME=/app
WORKDIR $APP_HOME
COPY . $APP_HOME
```

### EXPOSE - Khai b√°o ports

EXPOSE khai b√°o port m√† container s·∫Ω l·∫Øng nghe. L∆∞u √Ω: ƒë√¢y ch·ªâ l√† documentation, kh√¥ng th·ª±c s·ª± publish port.

```dockerfile
# Khai b√°o port 3000
EXPOSE 3000

# Khai b√°o nhi·ªÅu ports
EXPOSE 3000 8080

# Khai b√°o port v·ªõi protocol
EXPOSE 3000/tcp
EXPOSE 53/udp
```

### CMD vs ENTRYPOINT - ƒê·ªãnh nghƒ©a c√°ch ch·∫°y container

ƒê√¢y l√† hai instruction quan tr·ªçng nh·∫•t ƒë·ªÉ hi·ªÉu c√°ch container s·∫Ω ƒë∆∞·ª£c kh·ªüi ƒë·ªông.

**CMD**: ƒê·ªãnh nghƒ©a command m·∫∑c ƒë·ªãnh, c√≥ th·ªÉ b·ªã override khi run container.

```dockerfile
# Shell form
CMD echo "Hello World"

# Exec form (preferred)
CMD ["echo", "Hello World"]

# ƒê·ªÉ ch·∫°y ·ª©ng d·ª•ng Node.js
CMD ["node", "server.js"]
```

**ENTRYPOINT**: ƒê·ªãnh nghƒ©a command c·ªë ƒë·ªãnh, kh√¥ng th·ªÉ override.

```dockerfile
# Lu√¥n ch·∫°y node
ENTRYPOINT ["node"]

# K·∫øt h·ª£p v·ªõi CMD ƒë·ªÉ c√≥ default argument
ENTRYPOINT ["node"]
CMD ["server.js"]
```

**Khi n√†o s·ª≠ d·ª•ng c√°i g√¨?**
- S·ª≠ d·ª•ng CMD khi b·∫°n mu·ªën user c√≥ th·ªÉ thay ƒë·ªïi command
- S·ª≠ d·ª•ng ENTRYPOINT khi b·∫°n mu·ªën container lu√¥n ch·∫°y m·ªôt binary c·ª• th·ªÉ
- K·∫øt h·ª£p c·∫£ hai ƒë·ªÉ c√≥ flexibility v√† default values

---

## Layers v√† Docker Cache

### Hi·ªÉu v·ªÅ Docker Layers

M·ªói instruction trong Dockerfile t·∫°o ra m·ªôt layer. C√°c layers n√†y ƒë∆∞·ª£c stack l√™n nhau ƒë·ªÉ t·∫°o th√†nh image cu·ªëi c√πng. ƒêi·ªÅu n√†y gi·ªëng nh∆∞ vi·ªác x√¢y m·ªôt t√≤a nh√† - m·ªói t·∫ßng ƒë∆∞·ª£c x√¢y d·ª±a d·ª±a tr√™n t·∫ßng d∆∞·ªõi.

```dockerfile
FROM node:18           # Layer 1: Base image
WORKDIR /app          # Layer 2: Create working directory
COPY package.json .   # Layer 3: Copy package.json
RUN npm install       # Layer 4: Install dependencies
COPY . .              # Layer 5: Copy source code
CMD ["npm", "start"]  # Layer 6: Set default command
```

### Docker Build Cache

Docker s·ª≠ d·ª•ng cache ƒë·ªÉ tƒÉng t·ªëc qu√° tr√¨nh build. N·∫øu Docker ph√°t hi·ªán m·ªôt layer ch∆∞a thay ƒë·ªïi, n√≥ s·∫Ω s·ª≠ d·ª•ng l·∫°i layer ƒë√£ cached thay v√¨ build l·∫°i.

**Cache invalidation**: Khi m·ªôt layer thay ƒë·ªïi, t·∫•t c·∫£ layers sau ƒë√≥ s·∫Ω b·ªã rebuild.

```dockerfile
# T·ªët: Dependencies √≠t thay ƒë·ªïi, ƒë·ªÉ tr∆∞·ªõc
COPY package.json .
RUN npm install

# Source code thay ƒë·ªïi th∆∞·ªùng xuy√™n, ƒë·ªÉ sau
COPY . .

# Kh√¥ng t·ªët: M·ªói l·∫ßn thay ƒë·ªïi source code ph·∫£i install l·∫°i
COPY . .
RUN npm install
```

### T·ªëi ∆∞u h√≥a Cache Strategy

```dockerfile
# Strategy 1: Separate dependency installation
COPY package.json package-lock.json ./
RUN npm ci --only=production

# Strategy 2: Multi-stage ƒë·ªÉ t√°ch build v√† runtime
FROM node:18 AS builder
# ... build steps

FROM node:18-alpine AS runtime
# ... only copy built artifacts
```

---

## Best Practices c∆° b·∫£n

### 1. S·ª≠ d·ª•ng official images l√†m base

```dockerfile
# T·ªët: Official image, maintained t·ªët
FROM node:18-alpine

# Tr√°nh: Image kh√¥ng r√µ ngu·ªìn g·ªëc
FROM some-random-user/nodejs
```

### 2. Minimize layer count

```dockerfile
# Kh√¥ng t·ªët: Nhi·ªÅu layers kh√¥ng c·∫ßn thi·∫øt
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y vim
RUN apt-get clean

# T·ªët: K·∫øt h·ª£p th√†nh m·ªôt layer
RUN apt-get update && \
    apt-get install -y curl vim && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

### 3. Leverage build cache

```dockerfile
# T·ªët: Copy dependencies tr∆∞·ªõc, source code sau
COPY package*.json ./
RUN npm ci --only=production
COPY . .

# Kh√¥ng t·ªët: Copy all r·ªìi install
COPY . .
RUN npm ci --only=production
```

### 4. Use .dockerignore

T·∫°o file `.dockerignore` ƒë·ªÉ lo·∫°i tr·ª´ files kh√¥ng c·∫ßn thi·∫øt:

```
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.nyc_output
coverage
.vscode
```

### 5. Run as non-root user

```dockerfile
# T·∫°o user non-root
RUN groupadd -r nodejs && useradd -r -g nodejs nodejs

# Chuy·ªÉn ownership c·ªßa app directory
COPY --chown=nodejs:nodejs . .

# Switch to non-root user
USER nodejs
```

---

## C√°c instruction n√¢ng cao

### ARG - Build-time variables

ARG ƒë·ªãnh nghƒ©a variables ch·ªâ c√≥ s·∫µn trong qu√° tr√¨nh build.

```dockerfile
# ƒê·ªãnh nghƒ©a ARG
ARG NODE_VERSION=18
ARG BUILD_DATE

# S·ª≠ d·ª•ng ARG
FROM node:${NODE_VERSION}

# ARG c√≥ th·ªÉ c√≥ default value
ARG ENVIRONMENT=development

# S·ª≠ d·ª•ng trong RUN
RUN echo "Building for environment: $ENVIRONMENT"

# Build v·ªõi custom arguments
# docker build --build-arg NODE_VERSION=16 --build-arg ENVIRONMENT=production .
```

**S·ª± kh√°c bi·ªát ARG vs ENV**:
- ARG: Ch·ªâ c√≥ s·∫µn trong build time
- ENV: C√≥ s·∫µn c·∫£ build time v√† runtime

### LABEL - Metadata cho image

```dockerfile
# Basic labels
LABEL maintainer="developer@example.com"
LABEL version="1.0"
LABEL description="My awesome application"

# Multi-line labels
LABEL org.opencontainers.image.title="My App" \
      org.opencontainers.image.description="Application description" \
      org.opencontainers.image.version="1.0.0" \
      org.opencontainers.image.created="2023-01-01T00:00:00Z"
```

### VOLUME - Persistent data

```dockerfile
# Khai b√°o mount points
VOLUME ["/data"]
VOLUME ["/var/log", "/var/db"]

# T·∫°o directory tr∆∞·ªõc khi khai b√°o volume
RUN mkdir -p /data
VOLUME /data
```

### HEALTHCHECK - Container health monitoring

```dockerfile
# Basic health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Health check cho database
HEALTHCHECK --interval=10s --timeout=3s --start-period=30s --retries=3 \
  CMD pg_isready -U postgres || exit 1

# Disable inherited health check
HEALTHCHECK NONE
```

### ONBUILD - Triggered instructions

ONBUILD instructions ch·ªâ ƒë∆∞·ª£c th·ª±c thi khi image ƒë∆∞·ª£c s·ª≠ d·ª•ng l√†m base cho image kh√°c.

```dockerfile
# Base image for Node.js apps
FROM node:18
ONBUILD COPY package*.json ./
ONBUILD RUN npm ci --only=production
ONBUILD COPY . .
```

---

## Multi-stage builds

Multi-stage builds cho ph√©p s·ª≠ d·ª•ng nhi·ªÅu FROM statements trong c√πng m·ªôt Dockerfile, gi√∫p t·ªëi ∆∞u h√≥a size c·ªßa final image.

### T·∫°i sao c·∫ßn Multi-stage builds?

Trong qu√° tr√¨nh ph√°t tri·ªÉn ·ª©ng d·ª•ng, b·∫°n th∆∞·ªùng c·∫ßn:
- Build tools (compiler, bundler, test frameworks)
- Development dependencies
- Source code

Nh∆∞ng trong production, b·∫°n ch·ªâ c·∫ßn:
- Runtime environment
- Production dependencies
- Built artifacts

### Example: Node.js application

```dockerfile
# Stage 1: Build stage
FROM node:18 AS builder

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install ALL dependencies (including devDependencies)
RUN npm ci

# Copy source code
COPY . .

# Run tests
RUN npm test

# Build the application
RUN npm run build

# Stage 2: Production stage
FROM node:18-alpine AS production

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install only production dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy built application from builder stage
COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist

# Switch to non-root user
USER nextjs

# Expose port
EXPOSE 3000

# Start the application
CMD ["node", "dist/server.js"]
```

### Advanced Multi-stage patterns

```dockerfile
# Build stage v·ªõi specific target
FROM golang:1.19 AS go-builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o main .

# Test stage
FROM go-builder AS tester
RUN go test -v ./...

# Final stage
FROM alpine:latest AS production
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=go-builder /app/main .
CMD ["./main"]
```

### Build specific stages

```bash
# Build ch·ªâ test stage
docker build --target tester .

# Build production stage
docker build --target production -t myapp:prod .
```

---

## Security trong Dockerfile

### 1. S·ª≠ d·ª•ng non-root user

```dockerfile
# T·∫°o user v√† group
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Ho·∫∑c s·ª≠ d·ª•ng user c√≥ s·∫µn
RUN adduser --disabled-password --gecos '' appuser

# Chuy·ªÉn ownership
COPY --chown=appuser:appuser . /app

# Switch user
USER appuser
```

### 2. Minimize attack surface

```dockerfile
# S·ª≠ d·ª•ng minimal base images
FROM node:18-alpine  # Thay v√¨ node:18 (Ubuntu-based)

# X√≥a package manager sau khi c√†i ƒë·∫∑t
RUN apk add --no-cache python3 make g++ && \
    npm install && \
    apk del python3 make g++
```

### 3. Scan for vulnerabilities

```dockerfile
# C·∫≠p nh·∫≠t packages ƒë·ªÉ v√° l·ªói b·∫£o m·∫≠t
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y --no-install-recommends \
        curl \
        ca-certificates && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

### 4. Handle secrets properly

```dockerfile
# KH√îNG BAO GI·ªú l√†m th·∫ø n√†y
ENV SECRET_KEY=my-secret-key

# S·ª≠ d·ª•ng build secrets thay th·∫ø
# docker build --secret id=mysecret,src=./secret.txt .
RUN --mount=type=secret,id=mysecret \
    SECRET=$(cat /run/secrets/mysecret) && \
    echo "Secret: $SECRET"
```

### 5. Use specific versions

```dockerfile
# T·ªët: Version c·ª• th·ªÉ
FROM node:18.17.0-alpine3.18

# Kh√¥ng t·ªët: Version c√≥ th·ªÉ thay ƒë·ªïi
FROM node:latest
```

---

## Optimization v√† Performance

### 1. Image size optimization

```dockerfile
# S·ª≠ d·ª•ng Alpine Linux
FROM node:18-alpine

# Multi-stage builds
FROM node:18 AS builder
# ... build steps
FROM node:18-alpine AS production
COPY --from=builder /app/dist ./

# X√≥a cache sau khi c√†i ƒë·∫∑t
RUN apk add --no-cache python3 make g++ && \
    npm ci --only=production && \
    npm cache clean --force && \
    apk del python3 make g++
```

### 2. Layer caching optimization

```dockerfile
# Dependencies √≠t thay ƒë·ªïi, ƒë·ªÉ tr∆∞·ªõc
COPY package*.json ./
RUN npm ci --only=production

# Source code thay ƒë·ªïi th∆∞·ªùng xuy√™n, ƒë·ªÉ sau
COPY . .
```

### 3. Parallel builds

```dockerfile
# S·ª≠ d·ª•ng BuildKit ƒë·ªÉ enable parallel builds
# syntax=docker/dockerfile:1
FROM node:18 AS deps
COPY package*.json ./
RUN npm ci

FROM node:18 AS builder
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm run build

FROM node:18 AS runner
COPY --from=builder /app/dist ./dist
```

### 4. Use .dockerignore effectively

```
# .dockerignore
**/.git
**/node_modules
**/coverage
**/.env.local
**/README.md
Dockerfile
.dockerignore
```

---

## Troubleshooting v√† Debug

### Common issues v√† solutions

#### 1. Build context qu√° l·ªõn

**Problem**: Build ch·∫≠m v√¨ Docker g·ª≠i qu√° nhi·ªÅu files
**Solution**: S·ª≠ d·ª•ng .dockerignore

```
# .dockerignore
node_modules
.git
*.log
coverage/
```

#### 2. Cache kh√¥ng ho·∫°t ƒë·ªông

**Problem**: Docker rebuild t·∫•t c·∫£ layers m·∫∑c d√π kh√¥ng c√≥ g√¨ thay ƒë·ªïi
**Solution**: S·∫Øp x·∫øp l·∫°i order c·ªßa instructions

```dockerfile
# T·ªët: Dependencies tr∆∞·ªõc, source sau
COPY package*.json ./
RUN npm install
COPY . .

# Kh√¥ng t·ªët: Source tr∆∞·ªõc, dependencies sau
COPY . .
RUN npm install
```

#### 3. Permission issues

**Problem**: Container kh√¥ng th·ªÉ write v√†o mounted volumes
**Solution**: Set correct user permissions

```dockerfile
RUN adduser --disabled-password --gecos '' appuser
USER appuser
```

#### 4. Large image size

**Problem**: Image qu√° l·ªõn
**Solutions**:

```dockerfile
# 1. S·ª≠ d·ª•ng Alpine
FROM node:18-alpine

# 2. Multi-stage builds
FROM node:18 AS builder
# ... build
FROM node:18-alpine AS production
COPY --from=builder /app/dist ./

# 3. Cleanup trong c√πng layer
RUN apt-get update && \
    apt-get install -y package && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

### Debug techniques

#### 1. Interactive debugging

```bash
# Build ƒë·∫øn m·ªôt stage c·ª• th·ªÉ
docker build --target builder -t debug-image .

# Run container interactively
docker run -it debug-image /bin/sh
```

#### 2. Inspect layers

```bash
# Xem history c·ªßa image
docker history myimage:latest

# Inspect image details
docker inspect myimage:latest
```

#### 3. Build with verbose output

```bash
# Enable BuildKit v·ªõi debug
DOCKER_BUILDKIT=1 docker build --progress=plain .
```

---

## Examples th·ª±c t·∫ø

### 1. Node.js Express Application

```dockerfile
# syntax=docker/dockerfile:1

# Multi-stage build for Node.js app
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
# Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine to understand why libc6-compat might be needed.
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then yarn global add pnpm && pnpm i --frozen-lockfile; \
  else echo "Lockfile not found." && exit 1; \
  fi

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build the application
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# Copy built application
COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist
COPY --from=deps --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nextjs:nodejs /app/package.json ./package.json

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js

CMD ["node", "dist/server.js"]
```

### 2. Python FastAPI Application

```dockerfile
# syntax=docker/dockerfile:1

FROM python:3.11-slim as base

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Create virtual environment
FROM base as python-deps
RUN pip install poetry
ENV POETRY_HOME="/opt/poetry" \
    POETRY_CACHE_DIR=/opt/.cache

# Copy poetry files
COPY poetry.lock pyproject.toml ./

# Install dependencies
RUN poetry config virtualenvs.create false \
    && poetry install --no-dev --no-interaction --no-ansi

# Production stage
FROM base as production

# Create non-root user
RUN groupadd -r fastapi && useradd -r -g fastapi fastapi

# Set work directory
WORKDIR /app

# Copy installed packages from python-deps stage
COPY --from=python-deps /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=python-deps /usr/local/bin /usr/local/bin

# Copy application
COPY --chown=fastapi:fastapi . /app

# Switch to non-root user
USER fastapi

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

# Run the application
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 3. React Frontend Application

```dockerfile
# syntax=docker/dockerfile:1

# Stage 1: Build the React application
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Stage 2: Serve the application with Nginx
FROM nginx:alpine AS production

# Copy custom nginx config
COPY nginx.conf /etc/nginx/nginx.conf

# Copy built application from builder stage
COPY --from=builder /app/build /usr/share/nginx/html

# Add non-root user
RUN addgroup -g 1001 -S nginx-group && \
    adduser -S nginx-user -u 1001

# Change ownership of nginx directories
RUN chown -R nginx-user:nginx-group /var/cache/nginx && \
    chown -R nginx-user:nginx-group /var/log/nginx && \
    chown -R nginx-user:nginx-group /etc/nginx/conf.d

# Change ownership of html directory
RUN chown -R nginx-user:nginx-group /usr/share/nginx/html

# Switch to non-root user
USER nginx-user

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/ || exit 1

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
```

### 4. Go Microservice

```dockerfile
# syntax=docker/dockerfile:1

# Build stage
FROM golang:1.20-alpine AS builder

# Install git and ca-certificates (needed to be able to call HTTPS)
RUN apk --no-cache add git ca-certificates

# Create appuser
ENV USER=appuser
ENV UID=10001

RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "${UID}" \
    "${USER}"

WORKDIR /build

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build the binary
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags='-w -s -extldflags "-static"' \
    -a -installsuffix cgo \
    -o app .

# Final stage
FROM scratch

# Import the user and group files from the builder
COPY --from=builder /etc/passwd /etc/passwd
COPY --from=builder /etc/group /etc/group

# Copy ca-certificates for HTTPS
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/

# Copy the binary
COPY --from=builder /build/app /app

# Use the unprivileged user
USER appuser:appuser

# Expose port
EXPOSE 8080

# Run the binary
ENTRYPOINT ["/app"]
```

### 5. Database v·ªõi Custom Configuration

```dockerfile
# syntax=docker/dockerfile:1

FROM postgres:15-alpine

# Set environment variables
ENV POSTGRES_DB=myapp \
    POSTGRES_USER=myuser \
    POSTGRES_PASSWORD_FILE=/run/secrets/postgres_password

# Install additional packages
RUN apk add --no-cache \
    curl \
    && rm -rf /var/cache/apk/*

# Create directories for custom configuration
RUN mkdir -p /docker-entrypoint-initdb.d \
    /var/lib/postgresql/backup

# Copy custom configuration
COPY postgresql.conf /etc/postgresql/postgresql.conf
COPY pg_hba.conf /etc/postgresql/pg_hba.conf

# Copy initialization scripts
COPY init-scripts/*.sql /docker-entrypoint-initdb.d/

# Copy backup script
COPY backup.sh /usr/local/bin/backup.sh
RUN chmod +x /usr/local/bin/backup.sh

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=30s --retries=3 \
  CMD pg_isready -U $POSTGRES_USER -d $POSTGRES_DB || exit 1

# Expose port
EXPOSE 5432

# Use custom configuration
CMD ["postgres", "-c", "config_file=/etc/postgresql/postgresql.conf"]
```

---

## Advanced Patterns v√† Techniques

### 1. Dynamic Base Image Selection

```dockerfile
# syntax=docker/dockerfile:1

ARG VARIANT=alpine
FROM node:18-${VARIANT}

# Conditional logic based on variant
RUN if [ "$VARIANT" = "alpine" ]; then \
        apk add --no-cache python3 make g++; \
    else \
        apt-get update && apt-get install -y python3 make g++; \
    fi

WORKDIR /app
COPY . .
RUN npm install

CMD ["npm", "start"]
```

### 2. Build-time Secret Management

```dockerfile
# syntax=docker/dockerfile:1

FROM alpine:latest

# Mount secret during build
RUN --mount=type=secret,id=api_key \
    API_KEY=$(cat /run/secrets/api_key) && \
    wget --header="Authorization: Bearer $API_KEY" \
         https://api.example.com/data -O /tmp/data.json

# Secret kh√¥ng ƒë∆∞·ª£c l∆∞u trong layer
COPY . .
```

S·ª≠ d·ª•ng:
```bash
echo "secret-api-key" | docker build --secret id=api_key,src=- .
```

### 3. Cache Mount Optimization

```dockerfile
# syntax=docker/dockerfile:1

FROM node:18-alpine

WORKDIR /app

# Cache mount for npm cache
RUN --mount=type=cache,target=/root/.npm \
    npm install -g npm@latest

COPY package*.json ./

# Cache mount cho node_modules
RUN --mount=type=cache,target=/root/.npm \
    --mount=type=cache,target=/app/node_modules \
    npm ci

COPY . .
CMD ["npm", "start"]
```

### 4. Cross-platform Builds

```dockerfile
# syntax=docker/dockerfile:1

FROM --platform=$BUILDPLATFORM node:18-alpine AS builder

ARG TARGETPLATFORM
ARG BUILDPLATFORM

RUN echo "Building on $BUILDPLATFORM for $TARGETPLATFORM"

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM node:18-alpine
COPY --from=builder /app/dist ./dist
CMD ["node", "dist/server.js"]
```

Build cho multiple platforms:
```bash
docker buildx build --platform linux/amd64,linux/arm64 -t myapp:latest .
```

---

## Testing Dockerfile

### 1. Container Structure Tests

T·∫°o file `container-structure-test.yaml`:

```yaml
schemaVersion: 2.0.0

commandTests:
  - name: "app runs"
    command: "node"
    args: ["--version"]
    expectedOutput: ["v18.*"]

  - name: "user is not root"
    command: "whoami"
    expectedOutput: ["appuser"]

fileExistenceTests:
  - name: "app directory exists"
    path: "/app"
    shouldExist: true

  - name: "package.json exists"
    path: "/app/package.json"
    shouldExist: true

metadataTest:
  exposedPorts: ["3000"]
  env:
    - key: "NODE_ENV"
      value: "production"
```

Ch·∫°y tests:
```bash
container-structure-test test --image myapp:latest --config container-structure-test.yaml
```

### 2. Dockerfile Linting

S·ª≠ d·ª•ng hadolint ƒë·ªÉ ki·ªÉm tra Dockerfile:

```bash
# Install hadolint
brew install hadolint

# Lint Dockerfile
hadolint Dockerfile
```

T·∫°o `.hadolint.yaml` cho custom rules:

```yaml
ignored:
  - DL3008  # Pin versions in apt get install
  - DL3009  # Delete the apt-get lists after installing something

failure-threshold: error

format: json
```

### 3. Security Scanning

```bash
# Scan v·ªõi Trivy
trivy image myapp:latest

# Scan v·ªõi Snyk
snyk container test myapp:latest

# Scan v·ªõi Docker Scout
docker scout cves myapp:latest
```

---

## Production Considerations

### 1. Image Tagging Strategy

```dockerfile
# Build arguments for versioning
ARG VERSION=latest
ARG BUILD_DATE
ARG VCS_REF

# Labels for metadata
LABEL org.opencontainers.image.version=$VERSION \
      org.opencontainers.image.created=$BUILD_DATE \
      org.opencontainers.image.revision=$VCS_REF \
      org.opencontainers.image.source="https://github.com/company/myapp"
```

Build script:
```bash
#!/bin/bash
VERSION=${1:-latest}
BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
VCS_REF=$(git rev-parse --short HEAD)

docker build \
  --build-arg VERSION=$VERSION \
  --build-arg BUILD_DATE=$BUILD_DATE \
  --build-arg VCS_REF=$VCS_REF \
  -t myapp:$VERSION \
  -t myapp:latest \
  .
```

### 2. Health Checks Best Practices

```dockerfile
# Comprehensive health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:3000/health \
      --max-time 10 \
      --retry 3 \
      --retry-delay 5 \
      || exit 1

# Health check v·ªõi custom script
COPY healthcheck.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/healthcheck.sh

HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD /usr/local/bin/healthcheck.sh
```

`healthcheck.sh`:
```bash
#!/bin/sh
set -e

# Check if app is responding
if ! curl -f http://localhost:3000/health > /dev/null 2>&1; then
    echo "Health check failed: app not responding"
    exit 1
fi

# Check database connection
if ! curl -f http://localhost:3000/db-health > /dev/null 2>&1; then
    echo "Health check failed: database not accessible"
    exit 1
fi

echo "Health check passed"
exit 0
```

### 3. Monitoring v√† Observability

```dockerfile
# Add monitoring tools
RUN apt-get update && apt-get install -y \
    prometheus-node-exporter \
    && rm -rf /var/lib/apt/lists/*

# Copy monitoring configuration
COPY prometheus.yml /etc/prometheus/
COPY grafana-dashboard.json /etc/grafana/dashboards/

# Expose metrics port
EXPOSE 9090

# Add metrics collection
COPY metrics-collector.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/metrics-collector.sh
```

---

## Automation v√† CI/CD Integration

### 1. GitLab CI Integration

`.gitlab-ci.yml`:
```yaml
stages:
  - test
  - build
  - security
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

services:
  - docker:dind

dockerfile-lint:
  stage: test
  image: hadolint/hadolint:latest-debian
  script:
    - hadolint Dockerfile

build:
  stage: build
  image: docker:latest
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

security-scan:
  stage: security
  image: aquasec/trivy:latest
  script:
    - trivy image $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
```

### 2. GitHub Actions Integration

`.github/workflows/docker.yml`:
```yaml
name: Docker Build and Push

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Lint Dockerfile
      uses: hadolint/hadolint-action@v3.1.0
      with:
        dockerfile: Dockerfile
    
    - name: Build and push
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: myregistry/myapp:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
```

---

## Cheat Sheet - Quick Reference

### Essential Commands
```bash
# Build image
docker build -t myapp:latest .

# Build v·ªõi custom Dockerfile
docker build -f Dockerfile.prod -t myapp:prod .

# Build v·ªõi arguments
docker build --build-arg NODE_ENV=production -t myapp .

# Build multi-platform
docker buildx build --platform linux/amd64,linux/arm64 -t myapp .
```

### Common Patterns
```dockerfile
# Minimal Node.js app
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
USER node
EXPOSE 3000
CMD ["npm", "start"]

# Multi-stage build
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./
CMD ["node", "server.js"]
```

### Troubleshooting Commands
```bash
# Debug build
docker build --no-cache --progress=plain .

# Inspect image
docker inspect myapp:latest

# View image history
docker history myapp:latest

# Run interactive shell
docker run -it myapp:latest /bin/sh
```

---

## K·∫øt lu·∫≠n

Dockerfile l√† c√¥ng c·ª• m·∫°nh m·∫Ω ƒë·ªÉ containerize ·ª©ng d·ª•ng, nh∆∞ng ƒë·ªÉ s·ª≠ d·ª•ng hi·ªáu qu·∫£ c·∫ßn hi·ªÉu r√µ c√°c concepts v√† best practices. Nh·ªØng ƒëi·ªÉm quan tr·ªçng c·∫ßn nh·ªõ:

1. **Layer optimization**: S·∫Øp x·∫øp instructions h·ª£p l√Ω ƒë·ªÉ t·∫≠n d·ª•ng cache
2. **Security**: Lu√¥n ch·∫°y ·ª©ng d·ª•ng v·ªõi non-root user
3. **Size optimization**: S·ª≠ d·ª•ng multi-stage builds v√† minimal base images
4. **Maintainability**: S·ª≠ d·ª•ng explicit versions v√† proper documentation
5. **Testing**: Implement proper health checks v√† container testing

Dockerfile t·ªët kh√¥ng ch·ªâ ch·∫°y ƒë∆∞·ª£c m√† c√≤n secure, efficient v√† maintainable. Th·ª±c h√†nh th∆∞·ªùng xuy√™n v·ªõi c√°c patterns kh√°c nhau s·∫Ω gi√∫p b·∫°n master c√¥ng c·ª• n√†y.

### Next Steps

1. Th·ª±c h√†nh v·ªõi c√°c examples trong guide n√†y
2. ƒê·ªçc th√™m v·ªÅ Docker BuildKit features
3. T√¨m hi·ªÉu v·ªÅ container orchestration (Kubernetes, Docker Swarm)
4. H·ªçc v·ªÅ monitoring v√† logging trong containers
5. Explore advanced security practices

Happy containerizing! üê≥